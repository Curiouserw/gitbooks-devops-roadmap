# Elasticsearch性能优化

# 一、写入性能优化

在文档写入时，会根据_routing来计算（OperationRouting类）得出文档要写入哪个分片。这里的写入请求只会写主分片，当主分片写入成功后，会同时把写入请求发送给所有的副本分片，当副本分片写入成功后，会传回返回信息给主分片，主分片得到所有副本分片的返回信息后，再返回给客户端。

在写入时，我们可以在Request自己指定_routing，也可以在Mapping指定文档中的Field值作为_routing。如果没有指定_routing，则会把_id作为_routing进行计算。由于写入时，具有相同_routing的文档一定会分配在同一个分片上，所以如果是自定义的_routing，在查询时，一定要指定_routing进行查询，否则是查询不到文档的。这并不是局限性，恰恰相反，指定_routing的查询，性能上会好很多，因为指定_routing意味着直接去存储数据的shard上搜索，而不会搜索所有shard。



# 二、索引性能优化



## 段合并



## 关闭索引

# 三、搜索性能优化



# 

































# 优化索引速度

## 1. 使用bulk批量操作

批量请求将比单文档索引请求产生更好的性能。

为了知道批量请求的最佳大小，您应该在具有单个shard的单个节点上运行基准测试。首先尝试一次索引100个文档，然后索引200个，然后索引400个，等等，在每次基准测试运行时将批量请求中的文档数量增加一倍。当索引速度开始趋于稳定时，您就知道已经达到了数据批量请求的最佳大小。

## 2. 查询返回大小

尽量使用 Scroll滚动查询API。

## 3. 按照日期规划索引

## 4. 索引分片个数设置

## 5. 索引分片副本数设置

## 6. 禁止大文档

- 禁止单个Document的大小超过默认设置`http.max_content_length(默认值100MB)`（如果单个doc大小超过了设置值，elasticsearch会直接拒绝索引）。

- 虽然可修改`http.max_content_length`参数提高默认doc大小，但 Lucene引擎依旧会有2GB大小的限制

- 单个大doc会加重网络、内存和磁盘的消耗
- 



## 7. 禁止节点开启Swapping

## 8. 节点给系统缓存预留内存

文件系统缓存将用于缓冲I / O操作

## 9. 文档ID尽量自动生成

## 10. 节点硬件尽量选性能好的

## 11. 提高索引缓存区大小

## 12. 使用多线程分散写入操作

使用单个线程发送批处理写入请求

## 13. 调整索引刷新间：refresh_interval

默认情况下索引的refresh_interval为1秒,这意味着数据写1秒后就可以被搜索到,每次索引的 refresh 会产生一个新的 lucene 段,这会导致频繁的 segment merge 行为,如果你不需要这么高的搜索实时性,应该降低索引refresh 周期,如:index.refresh_interval: 120s



# 二、优化查询速度

# 三、优化硬盘使用